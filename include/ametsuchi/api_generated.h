// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_API_IROHA_H_
#define FLATBUFFERS_GENERATED_API_IROHA_H_

#include "flatbuffers/flatbuffers.h"

namespace iroha {

struct BaseObject;

struct SimpleAsset;

struct Asset;

struct Domain;

struct Account;

struct Peer;

struct Add;

struct Transfer;

struct Update;

struct Remove;

struct Batch;

struct Unbatch;

struct Contract;

struct TxSignature;

struct Transaction;

struct Response;

struct Request;

struct Query;

struct EventSignature;

struct ConsensusEvent;

enum class Object : uint8_t {
  NONE = 0,
  SimpleAsset = 1,
  Asset = 2,
  Domain = 3,
  Account = 4,
  Peer = 5,
  MIN = NONE,
  MAX = Peer
};

inline const char **EnumNamesObject() {
  static const char *names[] = { "NONE", "SimpleAsset", "Asset", "Domain", "Account", "Peer", nullptr };
  return names;
}

inline const char *EnumNameObject(Object e) { return EnumNamesObject()[static_cast<int>(e)]; }

template<typename T> struct ObjectTraits {
  static const Object enum_value = Object::NONE;
};

template<> struct ObjectTraits<SimpleAsset> {
  static const Object enum_value = Object::SimpleAsset;
};

template<> struct ObjectTraits<Asset> {
  static const Object enum_value = Object::Asset;
};

template<> struct ObjectTraits<Domain> {
  static const Object enum_value = Object::Domain;
};

template<> struct ObjectTraits<Account> {
  static const Object enum_value = Object::Account;
};

template<> struct ObjectTraits<Peer> {
  static const Object enum_value = Object::Peer;
};

inline bool VerifyObject(flatbuffers::Verifier &verifier, const void *union_obj, Object type);

enum class Command : uint8_t {
  NONE = 0,
  Add = 1,
  Transfer = 2,
  Update = 3,
  Remove = 4,
  Batch = 5,
  Unbatch = 6,
  Contract = 7,
  MIN = NONE,
  MAX = Contract
};

inline const char **EnumNamesCommand() {
  static const char *names[] = { "NONE", "Add", "Transfer", "Update", "Remove", "Batch", "Unbatch", "Contract", nullptr };
  return names;
}

inline const char *EnumNameCommand(Command e) { return EnumNamesCommand()[static_cast<int>(e)]; }

template<typename T> struct CommandTraits {
  static const Command enum_value = Command::NONE;
};

template<> struct CommandTraits<Add> {
  static const Command enum_value = Command::Add;
};

template<> struct CommandTraits<Transfer> {
  static const Command enum_value = Command::Transfer;
};

template<> struct CommandTraits<Update> {
  static const Command enum_value = Command::Update;
};

template<> struct CommandTraits<Remove> {
  static const Command enum_value = Command::Remove;
};

template<> struct CommandTraits<Batch> {
  static const Command enum_value = Command::Batch;
};

template<> struct CommandTraits<Unbatch> {
  static const Command enum_value = Command::Unbatch;
};

template<> struct CommandTraits<Contract> {
  static const Command enum_value = Command::Contract;
};

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *union_obj, Command type);

enum class QueryType : int8_t {
  TransactionHistory = 0,
  HashTree = 1,
  ObjectInformation = 2,
  MIN = TransactionHistory,
  MAX = ObjectInformation
};

inline const char **EnumNamesQueryType() {
  static const char *names[] = { "TransactionHistory", "HashTree", "ObjectInformation", nullptr };
  return names;
}

inline const char *EnumNameQueryType(QueryType e) { return EnumNamesQueryType()[static_cast<int>(e)]; }

enum class State : int8_t {
  Undetermined = 0,
  Commited = 1,
  Rejected = 2,
  MIN = Undetermined,
  MAX = Rejected
};

inline const char **EnumNamesState() {
  static const char *names[] = { "Undetermined", "Commited", "Rejected", nullptr };
  return names;
}

inline const char *EnumNameState(State e) { return EnumNamesState()[static_cast<int>(e)]; }

struct BaseObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TEXT = 4,
    VT_INTEGER = 6,
    VT_BOOLEAN = 8,
    VT_NAME = 10
  };
  const flatbuffers::String *text() const { return GetPointer<const flatbuffers::String *>(VT_TEXT); }
  int32_t integer() const { return GetField<int32_t>(VT_INTEGER, 0); }
  bool boolean() const { return GetField<uint8_t>(VT_BOOLEAN, 0) != 0; }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int32_t>(verifier, VT_INTEGER) &&
           VerifyField<uint8_t>(verifier, VT_BOOLEAN) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct BaseObjectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(BaseObject::VT_TEXT, text); }
  void add_integer(int32_t integer) { fbb_.AddElement<int32_t>(BaseObject::VT_INTEGER, integer, 0); }
  void add_boolean(bool boolean) { fbb_.AddElement<uint8_t>(BaseObject::VT_BOOLEAN, static_cast<uint8_t>(boolean), 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(BaseObject::VT_NAME, name); }
  BaseObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BaseObjectBuilder &operator=(const BaseObjectBuilder &);
  flatbuffers::Offset<BaseObject> Finish() {
    auto o = flatbuffers::Offset<BaseObject>(fbb_.EndTable(start_, 4));
    fbb_.Required(o, BaseObject::VT_NAME);  // name
    return o;
  }
};

inline flatbuffers::Offset<BaseObject> CreateBaseObject(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    int32_t integer = 0,
    bool boolean = false,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  BaseObjectBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_integer(integer);
  builder_.add_text(text);
  builder_.add_boolean(boolean);
  return builder_.Finish();
}

inline flatbuffers::Offset<BaseObject> CreateBaseObjectDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    int32_t integer = 0,
    bool boolean = false,
    const char *name = nullptr) {
  return CreateBaseObject(_fbb, text ? _fbb.CreateString(text) : 0, integer, boolean, name ? _fbb.CreateString(name) : 0);
}

struct SimpleAsset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DOMAIN = 6,
    VT_OBJECT = 8,
    VT_SMARTCONTRACTNAME = 10
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Domain *domain() const { return GetPointer<const Domain *>(VT_DOMAIN); }
  const BaseObject *object() const { return GetPointer<const BaseObject *>(VT_OBJECT); }
  const flatbuffers::String *smartContractName() const { return GetPointer<const flatbuffers::String *>(VT_SMARTCONTRACTNAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN) &&
           verifier.VerifyTable(domain()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           verifier.VerifyTable(object()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SMARTCONTRACTNAME) &&
           verifier.Verify(smartContractName()) &&
           verifier.EndTable();
  }
};

struct SimpleAssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(SimpleAsset::VT_NAME, name); }
  void add_domain(flatbuffers::Offset<Domain> domain) { fbb_.AddOffset(SimpleAsset::VT_DOMAIN, domain); }
  void add_object(flatbuffers::Offset<BaseObject> object) { fbb_.AddOffset(SimpleAsset::VT_OBJECT, object); }
  void add_smartContractName(flatbuffers::Offset<flatbuffers::String> smartContractName) { fbb_.AddOffset(SimpleAsset::VT_SMARTCONTRACTNAME, smartContractName); }
  SimpleAssetBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SimpleAssetBuilder &operator=(const SimpleAssetBuilder &);
  flatbuffers::Offset<SimpleAsset> Finish() {
    auto o = flatbuffers::Offset<SimpleAsset>(fbb_.EndTable(start_, 4));
    fbb_.Required(o, SimpleAsset::VT_DOMAIN);  // domain
    return o;
  }
};

inline flatbuffers::Offset<SimpleAsset> CreateSimpleAsset(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Domain> domain = 0,
    flatbuffers::Offset<BaseObject> object = 0,
    flatbuffers::Offset<flatbuffers::String> smartContractName = 0) {
  SimpleAssetBuilder builder_(_fbb);
  builder_.add_smartContractName(smartContractName);
  builder_.add_object(object);
  builder_.add_domain(domain);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SimpleAsset> CreateSimpleAssetDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Domain> domain = 0,
    flatbuffers::Offset<BaseObject> object = 0,
    const char *smartContractName = nullptr) {
  return CreateSimpleAsset(_fbb, name ? _fbb.CreateString(name) : 0, domain, object, smartContractName ? _fbb.CreateString(smartContractName) : 0);
}

struct Asset FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DOMAIN = 6,
    VT_OBJECTS = 8,
    VT_SMARTCONTRACTNAME = 10
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Domain *domain() const { return GetPointer<const Domain *>(VT_DOMAIN); }
  const flatbuffers::Vector<flatbuffers::Offset<BaseObject>> *objects() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BaseObject>> *>(VT_OBJECTS); }
  const flatbuffers::String *smartContractName() const { return GetPointer<const flatbuffers::String *>(VT_SMARTCONTRACTNAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_DOMAIN) &&
           verifier.VerifyTable(domain()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECTS) &&
           verifier.Verify(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SMARTCONTRACTNAME) &&
           verifier.Verify(smartContractName()) &&
           verifier.EndTable();
  }
};

struct AssetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Asset::VT_NAME, name); }
  void add_domain(flatbuffers::Offset<Domain> domain) { fbb_.AddOffset(Asset::VT_DOMAIN, domain); }
  void add_objects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BaseObject>>> objects) { fbb_.AddOffset(Asset::VT_OBJECTS, objects); }
  void add_smartContractName(flatbuffers::Offset<flatbuffers::String> smartContractName) { fbb_.AddOffset(Asset::VT_SMARTCONTRACTNAME, smartContractName); }
  AssetBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AssetBuilder &operator=(const AssetBuilder &);
  flatbuffers::Offset<Asset> Finish() {
    auto o = flatbuffers::Offset<Asset>(fbb_.EndTable(start_, 4));
    fbb_.Required(o, Asset::VT_DOMAIN);  // domain
    return o;
  }
};

inline flatbuffers::Offset<Asset> CreateAsset(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Domain> domain = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BaseObject>>> objects = 0,
    flatbuffers::Offset<flatbuffers::String> smartContractName = 0) {
  AssetBuilder builder_(_fbb);
  builder_.add_smartContractName(smartContractName);
  builder_.add_objects(objects);
  builder_.add_domain(domain);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Asset> CreateAssetDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Domain> domain = 0,
    const std::vector<flatbuffers::Offset<BaseObject>> *objects = nullptr,
    const char *smartContractName = nullptr) {
  return CreateAsset(_fbb, name ? _fbb.CreateString(name) : 0, domain, objects ? _fbb.CreateVector<flatbuffers::Offset<BaseObject>>(*objects) : 0, smartContractName ? _fbb.CreateString(smartContractName) : 0);
}

struct Domain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OWNERPUBLICKEY = 4,
    VT_NAME = 6
  };
  const flatbuffers::String *ownerPublicKey() const { return GetPointer<const flatbuffers::String *>(VT_OWNERPUBLICKEY); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OWNERPUBLICKEY) &&
           verifier.Verify(ownerPublicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
};

struct DomainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ownerPublicKey(flatbuffers::Offset<flatbuffers::String> ownerPublicKey) { fbb_.AddOffset(Domain::VT_OWNERPUBLICKEY, ownerPublicKey); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Domain::VT_NAME, name); }
  DomainBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DomainBuilder &operator=(const DomainBuilder &);
  flatbuffers::Offset<Domain> Finish() {
    auto o = flatbuffers::Offset<Domain>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Domain> CreateDomain(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> ownerPublicKey = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  DomainBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_ownerPublicKey(ownerPublicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Domain> CreateDomainDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *ownerPublicKey = nullptr,
    const char *name = nullptr) {
  return CreateDomain(_fbb, ownerPublicKey ? _fbb.CreateString(ownerPublicKey) : 0, name ? _fbb.CreateString(name) : 0);
}

struct Account FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_ASSETS = 6
  };
  const flatbuffers::String *publicKey() const { return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY); }
  const flatbuffers::Vector<flatbuffers::Offset<Asset>> *assets() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Asset>> *>(VT_ASSETS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ASSETS) &&
           verifier.Verify(assets()) &&
           verifier.VerifyVectorOfTables(assets()) &&
           verifier.EndTable();
  }
};

struct AccountBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) { fbb_.AddOffset(Account::VT_PUBLICKEY, publicKey); }
  void add_assets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> assets) { fbb_.AddOffset(Account::VT_ASSETS, assets); }
  AccountBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AccountBuilder &operator=(const AccountBuilder &);
  flatbuffers::Offset<Account> Finish() {
    auto o = flatbuffers::Offset<Account>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Account> CreateAccount(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Asset>>> assets = 0) {
  AccountBuilder builder_(_fbb);
  builder_.add_assets(assets);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Account> CreateAccountDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const std::vector<flatbuffers::Offset<Asset>> *assets = nullptr) {
  return CreateAccount(_fbb, publicKey ? _fbb.CreateString(publicKey) : 0, assets ? _fbb.CreateVector<flatbuffers::Offset<Asset>>(*assets) : 0);
}

struct Peer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_ADDRESS = 6
  };
  const flatbuffers::String *publicKey() const { return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY); }
  const flatbuffers::String *address() const { return GetPointer<const flatbuffers::String *>(VT_ADDRESS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           verifier.EndTable();
  }
};

struct PeerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) { fbb_.AddOffset(Peer::VT_PUBLICKEY, publicKey); }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) { fbb_.AddOffset(Peer::VT_ADDRESS, address); }
  PeerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PeerBuilder &operator=(const PeerBuilder &);
  flatbuffers::Offset<Peer> Finish() {
    auto o = flatbuffers::Offset<Peer>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Peer> CreatePeer(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0) {
  PeerBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<Peer> CreatePeerDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *address = nullptr) {
  return CreatePeer(_fbb, publicKey ? _fbb.CreateString(publicKey) : 0, address ? _fbb.CreateString(address) : 0);
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const { return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) { fbb_.AddElement<uint8_t>(Add::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(Add::VT_OBJECT, object); }
  AddBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    auto o = flatbuffers::Offset<Add>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, Add::VT_OBJECT);  // object
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  AddBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Transfer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECEIVER = 4,
    VT_OBJECT_TYPE = 6,
    VT_OBJECT = 8
  };
  const flatbuffers::String *receiver() const { return GetPointer<const flatbuffers::String *>(VT_RECEIVER); }
  Object object_type() const { return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_RECEIVER) &&
           verifier.Verify(receiver()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct TransferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_receiver(flatbuffers::Offset<flatbuffers::String> receiver) { fbb_.AddOffset(Transfer::VT_RECEIVER, receiver); }
  void add_object_type(Object object_type) { fbb_.AddElement<uint8_t>(Transfer::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(Transfer::VT_OBJECT, object); }
  TransferBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TransferBuilder &operator=(const TransferBuilder &);
  flatbuffers::Offset<Transfer> Finish() {
    auto o = flatbuffers::Offset<Transfer>(fbb_.EndTable(start_, 3));
    fbb_.Required(o, Transfer::VT_RECEIVER);  // receiver
    fbb_.Required(o, Transfer::VT_OBJECT);  // object
    return o;
  }
};

inline flatbuffers::Offset<Transfer> CreateTransfer(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> receiver = 0,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  TransferBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_receiver(receiver);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transfer> CreateTransferDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *receiver = nullptr,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateTransfer(_fbb, receiver ? _fbb.CreateString(receiver) : 0, object_type, object);
}

struct Update FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const { return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct UpdateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) { fbb_.AddElement<uint8_t>(Update::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(Update::VT_OBJECT, object); }
  UpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UpdateBuilder &operator=(const UpdateBuilder &);
  flatbuffers::Offset<Update> Finish() {
    auto o = flatbuffers::Offset<Update>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, Update::VT_OBJECT);  // object
    return o;
  }
};

inline flatbuffers::Offset<Update> CreateUpdate(flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  UpdateBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Remove FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6
  };
  Object object_type() const { return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct RemoveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) { fbb_.AddElement<uint8_t>(Remove::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(Remove::VT_OBJECT, object); }
  RemoveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RemoveBuilder &operator=(const RemoveBuilder &);
  flatbuffers::Offset<Remove> Finish() {
    auto o = flatbuffers::Offset<Remove>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, Remove::VT_OBJECT);  // object
    return o;
  }
};

inline flatbuffers::Offset<Remove> CreateRemove(flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  RemoveBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

struct Batch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALIAS = 4,
    VT_COMMANDS = 6
  };
  const flatbuffers::String *alias() const { return GetPointer<const flatbuffers::String *>(VT_ALIAS); }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *commands() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_COMMANDS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMANDS) &&
           verifier.Verify(commands()) &&
           verifier.VerifyVectorOfStrings(commands()) &&
           verifier.EndTable();
  }
};

struct BatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alias(flatbuffers::Offset<flatbuffers::String> alias) { fbb_.AddOffset(Batch::VT_ALIAS, alias); }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands) { fbb_.AddOffset(Batch::VT_COMMANDS, commands); }
  BatchBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BatchBuilder &operator=(const BatchBuilder &);
  flatbuffers::Offset<Batch> Finish() {
    auto o = flatbuffers::Offset<Batch>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, Batch::VT_ALIAS);  // alias
    return o;
  }
};

inline flatbuffers::Offset<Batch> CreateBatch(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> alias = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> commands = 0) {
  BatchBuilder builder_(_fbb);
  builder_.add_commands(commands);
  builder_.add_alias(alias);
  return builder_.Finish();
}

inline flatbuffers::Offset<Batch> CreateBatchDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *alias = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *commands = nullptr) {
  return CreateBatch(_fbb, alias ? _fbb.CreateString(alias) : 0, commands ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*commands) : 0);
}

struct Unbatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALIAS = 4
  };
  const flatbuffers::String *alias() const { return GetPointer<const flatbuffers::String *>(VT_ALIAS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_ALIAS) &&
           verifier.Verify(alias()) &&
           verifier.EndTable();
  }
};

struct UnbatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alias(flatbuffers::Offset<flatbuffers::String> alias) { fbb_.AddOffset(Unbatch::VT_ALIAS, alias); }
  UnbatchBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UnbatchBuilder &operator=(const UnbatchBuilder &);
  flatbuffers::Offset<Unbatch> Finish() {
    auto o = flatbuffers::Offset<Unbatch>(fbb_.EndTable(start_, 1));
    fbb_.Required(o, Unbatch::VT_ALIAS);  // alias
    return o;
  }
};

inline flatbuffers::Offset<Unbatch> CreateUnbatch(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> alias = 0) {
  UnbatchBuilder builder_(_fbb);
  builder_.add_alias(alias);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unbatch> CreateUnbatchDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *alias = nullptr) {
  return CreateUnbatch(_fbb, alias ? _fbb.CreateString(alias) : 0);
}

struct Contract FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBJECT_TYPE = 4,
    VT_OBJECT = 6,
    VT_COMMAND = 8,
    VT_CONTRACTNAME = 10
  };
  Object object_type() const { return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  const flatbuffers::String *command() const { return GetPointer<const flatbuffers::String *>(VT_COMMAND); }
  const flatbuffers::String *contractName() const { return GetPointer<const flatbuffers::String *>(VT_CONTRACTNAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           verifier.Verify(command()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CONTRACTNAME) &&
           verifier.Verify(contractName()) &&
           verifier.EndTable();
  }
};

struct ContractBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_type(Object object_type) { fbb_.AddElement<uint8_t>(Contract::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(Contract::VT_OBJECT, object); }
  void add_command(flatbuffers::Offset<flatbuffers::String> command) { fbb_.AddOffset(Contract::VT_COMMAND, command); }
  void add_contractName(flatbuffers::Offset<flatbuffers::String> contractName) { fbb_.AddOffset(Contract::VT_CONTRACTNAME, contractName); }
  ContractBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ContractBuilder &operator=(const ContractBuilder &);
  flatbuffers::Offset<Contract> Finish() {
    auto o = flatbuffers::Offset<Contract>(fbb_.EndTable(start_, 4));
    fbb_.Required(o, Contract::VT_OBJECT);  // object
    fbb_.Required(o, Contract::VT_CONTRACTNAME);  // contractName
    return o;
  }
};

inline flatbuffers::Offset<Contract> CreateContract(flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0,
    flatbuffers::Offset<flatbuffers::String> command = 0,
    flatbuffers::Offset<flatbuffers::String> contractName = 0) {
  ContractBuilder builder_(_fbb);
  builder_.add_contractName(contractName);
  builder_.add_command(command);
  builder_.add_object(object);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Contract> CreateContractDirect(flatbuffers::FlatBufferBuilder &_fbb,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0,
    const char *command = nullptr,
    const char *contractName = nullptr) {
  return CreateContract(_fbb, object_type, object, command ? _fbb.CreateString(command) : 0, contractName ? _fbb.CreateString(contractName) : 0);
}

struct TxSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::String *publicKey() const { return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY); }
  const flatbuffers::String *signature() const { return GetPointer<const flatbuffers::String *>(VT_SIGNATURE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.Verify(signature()) &&
           verifier.EndTable();
  }
};

struct TxSignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) { fbb_.AddOffset(TxSignature::VT_PUBLICKEY, publicKey); }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) { fbb_.AddOffset(TxSignature::VT_SIGNATURE, signature); }
  TxSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TxSignatureBuilder &operator=(const TxSignatureBuilder &);
  flatbuffers::Offset<TxSignature> Finish() {
    auto o = flatbuffers::Offset<TxSignature>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, TxSignature::VT_PUBLICKEY);  // publicKey
    fbb_.Required(o, TxSignature::VT_SIGNATURE);  // signature
    return o;
  }
};

inline flatbuffers::Offset<TxSignature> CreateTxSignature(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0) {
  TxSignatureBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<TxSignature> CreateTxSignatureDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *signature = nullptr) {
  return CreateTxSignature(_fbb, publicKey ? _fbb.CreateString(publicKey) : 0, signature ? _fbb.CreateString(signature) : 0);
}

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SENDER = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8,
    VT_TXSIGNATURES = 10,
    VT_HASH = 12
  };
  const flatbuffers::String *sender() const { return GetPointer<const flatbuffers::String *>(VT_SENDER); }
  Command command_type() const { return static_cast<Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0)); }
  const void *command() const { return GetPointer<const void *>(VT_COMMAND); }
  const flatbuffers::Vector<flatbuffers::Offset<TxSignature>> *txSignatures() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TxSignature>> *>(VT_TXSIGNATURES); }
  const flatbuffers::String *hash() const { return GetPointer<const flatbuffers::String *>(VT_HASH); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SENDER) &&
           verifier.Verify(sender()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TXSIGNATURES) &&
           verifier.Verify(txSignatures()) &&
           verifier.VerifyVectorOfTables(txSignatures()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           verifier.EndTable();
  }
};

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sender(flatbuffers::Offset<flatbuffers::String> sender) { fbb_.AddOffset(Transaction::VT_SENDER, sender); }
  void add_command_type(Command command_type) { fbb_.AddElement<uint8_t>(Transaction::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0); }
  void add_command(flatbuffers::Offset<void> command) { fbb_.AddOffset(Transaction::VT_COMMAND, command); }
  void add_txSignatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TxSignature>>> txSignatures) { fbb_.AddOffset(Transaction::VT_TXSIGNATURES, txSignatures); }
  void add_hash(flatbuffers::Offset<flatbuffers::String> hash) { fbb_.AddOffset(Transaction::VT_HASH, hash); }
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    auto o = flatbuffers::Offset<Transaction>(fbb_.EndTable(start_, 5));
    fbb_.Required(o, Transaction::VT_SENDER);  // sender
    fbb_.Required(o, Transaction::VT_COMMAND);  // command
    fbb_.Required(o, Transaction::VT_TXSIGNATURES);  // txSignatures
    fbb_.Required(o, Transaction::VT_HASH);  // hash
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> sender = 0,
    Command command_type = Command::NONE,
    flatbuffers::Offset<void> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TxSignature>>> txSignatures = 0,
    flatbuffers::Offset<flatbuffers::String> hash = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_hash(hash);
  builder_.add_txSignatures(txSignatures);
  builder_.add_command(command);
  builder_.add_sender(sender);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *sender = nullptr,
    Command command_type = Command::NONE,
    flatbuffers::Offset<void> command = 0,
    const std::vector<flatbuffers::Offset<TxSignature>> *txSignatures = nullptr,
    const char *hash = nullptr) {
  return CreateTransaction(_fbb, sender ? _fbb.CreateString(sender) : 0, command_type, command, txSignatures ? _fbb.CreateVector<flatbuffers::Offset<TxSignature>>(*txSignatures) : 0, hash ? _fbb.CreateString(hash) : 0);
}

struct Response FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_STATUS = 4,
    VT_MESSAGE = 6,
    VT_TRANSACTION = 8,
    VT_OBJECT_TYPE = 10,
    VT_OBJECT = 12
  };
  int32_t status() const { return GetField<int32_t>(VT_STATUS, 0); }
  const flatbuffers::String *message() const { return GetPointer<const flatbuffers::String *>(VT_MESSAGE); }
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION); }
  Object object_type() const { return static_cast<Object>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STATUS) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyObject(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct ResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status(int32_t status) { fbb_.AddElement<int32_t>(Response::VT_STATUS, status, 0); }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) { fbb_.AddOffset(Response::VT_MESSAGE, message); }
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) { fbb_.AddOffset(Response::VT_TRANSACTION, transaction); }
  void add_object_type(Object object_type) { fbb_.AddElement<uint8_t>(Response::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(Response::VT_OBJECT, object); }
  ResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ResponseBuilder &operator=(const ResponseBuilder &);
  flatbuffers::Offset<Response> Finish() {
    auto o = flatbuffers::Offset<Response>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<Response> CreateResponse(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  ResponseBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_transaction(transaction);
  builder_.add_message(message);
  builder_.add_status(status);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Response> CreateResponseDirect(flatbuffers::FlatBufferBuilder &_fbb,
    int32_t status = 0,
    const char *message = nullptr,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr,
    Object object_type = Object::NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateResponse(_fbb, status, message ? _fbb.CreateString(message) : 0, transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0, object_type, object);
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRANSACTION = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           verifier.EndTable();
  }
};

struct RequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) { fbb_.AddOffset(Request::VT_TRANSACTION, transaction); }
  RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    auto o = flatbuffers::Offset<Request>(fbb_.EndTable(start_, 1));
    fbb_.Required(o, Request::VT_TRANSACTION);  // transaction
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_transaction(transaction);
  return builder_.Finish();
}

inline flatbuffers::Offset<Request> CreateRequestDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr) {
  return CreateRequest(_fbb, transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0);
}

struct Query FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_UUID = 6
  };
  QueryType type() const { return static_cast<QueryType>(GetField<int8_t>(VT_TYPE, 0)); }
  const flatbuffers::String *uuid() const { return GetPointer<const flatbuffers::String *>(VT_UUID); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UUID) &&
           verifier.Verify(uuid()) &&
           verifier.EndTable();
  }
};

struct QueryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(QueryType type) { fbb_.AddElement<int8_t>(Query::VT_TYPE, static_cast<int8_t>(type), 0); }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) { fbb_.AddOffset(Query::VT_UUID, uuid); }
  QueryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  QueryBuilder &operator=(const QueryBuilder &);
  flatbuffers::Offset<Query> Finish() {
    auto o = flatbuffers::Offset<Query>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Query> CreateQuery(flatbuffers::FlatBufferBuilder &_fbb,
    QueryType type = QueryType::TransactionHistory,
    flatbuffers::Offset<flatbuffers::String> uuid = 0) {
  QueryBuilder builder_(_fbb);
  builder_.add_uuid(uuid);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Query> CreateQueryDirect(flatbuffers::FlatBufferBuilder &_fbb,
    QueryType type = QueryType::TransactionHistory,
    const char *uuid = nullptr) {
  return CreateQuery(_fbb, type, uuid ? _fbb.CreateString(uuid) : 0);
}

struct EventSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PUBLICKEY = 4,
    VT_SIGNATURE = 6
  };
  const flatbuffers::String *publicKey() const { return GetPointer<const flatbuffers::String *>(VT_PUBLICKEY); }
  const flatbuffers::String *signature() const { return GetPointer<const flatbuffers::String *>(VT_SIGNATURE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_PUBLICKEY) &&
           verifier.Verify(publicKey()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATURE) &&
           verifier.Verify(signature()) &&
           verifier.EndTable();
  }
};

struct EventSignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_publicKey(flatbuffers::Offset<flatbuffers::String> publicKey) { fbb_.AddOffset(EventSignature::VT_PUBLICKEY, publicKey); }
  void add_signature(flatbuffers::Offset<flatbuffers::String> signature) { fbb_.AddOffset(EventSignature::VT_SIGNATURE, signature); }
  EventSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EventSignatureBuilder &operator=(const EventSignatureBuilder &);
  flatbuffers::Offset<EventSignature> Finish() {
    auto o = flatbuffers::Offset<EventSignature>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, EventSignature::VT_PUBLICKEY);  // publicKey
    fbb_.Required(o, EventSignature::VT_SIGNATURE);  // signature
    return o;
  }
};

inline flatbuffers::Offset<EventSignature> CreateEventSignature(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> publicKey = 0,
    flatbuffers::Offset<flatbuffers::String> signature = 0) {
  EventSignatureBuilder builder_(_fbb);
  builder_.add_signature(signature);
  builder_.add_publicKey(publicKey);
  return builder_.Finish();
}

inline flatbuffers::Offset<EventSignature> CreateEventSignatureDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *publicKey = nullptr,
    const char *signature = nullptr) {
  return CreateEventSignature(_fbb, publicKey ? _fbb.CreateString(publicKey) : 0, signature ? _fbb.CreateString(signature) : 0);
}

struct ConsensusEvent FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRANSACTION = 4,
    VT_EVENTSIGNATURES = 6,
    VT_STATE = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *transaction() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Transaction>> *>(VT_TRANSACTION); }
  const flatbuffers::Vector<flatbuffers::Offset<EventSignature>> *eventSignatures() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventSignature>> *>(VT_EVENTSIGNATURES); }
  State state() const { return static_cast<State>(GetField<int8_t>(VT_STATE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_TRANSACTION) &&
           verifier.Verify(transaction()) &&
           verifier.VerifyVectorOfTables(transaction()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_EVENTSIGNATURES) &&
           verifier.Verify(eventSignatures()) &&
           verifier.VerifyVectorOfTables(eventSignatures()) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           verifier.EndTable();
  }
};

struct ConsensusEventBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transaction(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction) { fbb_.AddOffset(ConsensusEvent::VT_TRANSACTION, transaction); }
  void add_eventSignatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventSignature>>> eventSignatures) { fbb_.AddOffset(ConsensusEvent::VT_EVENTSIGNATURES, eventSignatures); }
  void add_state(State state) { fbb_.AddElement<int8_t>(ConsensusEvent::VT_STATE, static_cast<int8_t>(state), 0); }
  ConsensusEventBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ConsensusEventBuilder &operator=(const ConsensusEventBuilder &);
  flatbuffers::Offset<ConsensusEvent> Finish() {
    auto o = flatbuffers::Offset<ConsensusEvent>(fbb_.EndTable(start_, 3));
    fbb_.Required(o, ConsensusEvent::VT_TRANSACTION);  // transaction
    return o;
  }
};

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEvent(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Transaction>>> transaction = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventSignature>>> eventSignatures = 0,
    State state = State::Undetermined) {
  ConsensusEventBuilder builder_(_fbb);
  builder_.add_eventSignatures(eventSignatures);
  builder_.add_transaction(transaction);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConsensusEvent> CreateConsensusEventDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Transaction>> *transaction = nullptr,
    const std::vector<flatbuffers::Offset<EventSignature>> *eventSignatures = nullptr,
    State state = State::Undetermined) {
  return CreateConsensusEvent(_fbb, transaction ? _fbb.CreateVector<flatbuffers::Offset<Transaction>>(*transaction) : 0, eventSignatures ? _fbb.CreateVector<flatbuffers::Offset<EventSignature>>(*eventSignatures) : 0, state);
}

inline bool VerifyObject(flatbuffers::Verifier &verifier, const void *union_obj, Object type) {
  switch (type) {
    case Object::NONE: return true;
    case Object::SimpleAsset: return verifier.VerifyTable(reinterpret_cast<const SimpleAsset *>(union_obj));
    case Object::Asset: return verifier.VerifyTable(reinterpret_cast<const Asset *>(union_obj));
    case Object::Domain: return verifier.VerifyTable(reinterpret_cast<const Domain *>(union_obj));
    case Object::Account: return verifier.VerifyTable(reinterpret_cast<const Account *>(union_obj));
    case Object::Peer: return verifier.VerifyTable(reinterpret_cast<const Peer *>(union_obj));
    default: return false;
  }
}

inline bool VerifyCommand(flatbuffers::Verifier &verifier, const void *union_obj, Command type) {
  switch (type) {
    case Command::NONE: return true;
    case Command::Add: return verifier.VerifyTable(reinterpret_cast<const Add *>(union_obj));
    case Command::Transfer: return verifier.VerifyTable(reinterpret_cast<const Transfer *>(union_obj));
    case Command::Update: return verifier.VerifyTable(reinterpret_cast<const Update *>(union_obj));
    case Command::Remove: return verifier.VerifyTable(reinterpret_cast<const Remove *>(union_obj));
    case Command::Batch: return verifier.VerifyTable(reinterpret_cast<const Batch *>(union_obj));
    case Command::Unbatch: return verifier.VerifyTable(reinterpret_cast<const Unbatch *>(union_obj));
    case Command::Contract: return verifier.VerifyTable(reinterpret_cast<const Contract *>(union_obj));
    default: return false;
  }
}

inline const iroha::ConsensusEvent *GetConsensusEvent(const void *buf) {
  return flatbuffers::GetRoot<iroha::ConsensusEvent>(buf);
}

inline const char *ConsensusEventIdentifier() {
  return "IROH";
}

inline bool ConsensusEventBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, ConsensusEventIdentifier());
}

inline bool VerifyConsensusEventBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<iroha::ConsensusEvent>(ConsensusEventIdentifier());
}

inline const char *ConsensusEventExtension() { return "iroha"; }

inline void FinishConsensusEventBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<iroha::ConsensusEvent> root) {
  fbb.Finish(root, ConsensusEventIdentifier());
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_API_IROHA_H_
