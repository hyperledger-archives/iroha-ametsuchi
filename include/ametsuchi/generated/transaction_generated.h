// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_
#define FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_

#include "flatbuffers/flatbuffers.h"

#include "account_generated.h"
#include "asset_generated.h"
#include "commands_generated.h"
#include "primitives_generated.h"

namespace iroha {

struct Transaction;

struct Attachment;

struct Transaction FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CREATORPUBKEY = 4,
    VT_COMMAND_TYPE = 6,
    VT_COMMAND = 8,
    VT_SIGNATURES = 10,
    VT_HASH = 12,
    VT_ATTACHMENT = 14
  };
  const flatbuffers::String *creatorPubKey() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATORPUBKEY);
  }
  flatbuffers::String *mutable_creatorPubKey() {
    return GetPointer<flatbuffers::String *>(VT_CREATORPUBKEY);
  }
  iroha::Command command_type() const {
    return static_cast<iroha::Command>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  bool mutate_command_type(iroha::Command _command_type) {
    return SetField<uint8_t>(VT_COMMAND_TYPE, static_cast<uint8_t>(_command_type), 0);
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const iroha::AssetCreate *command_as_AssetCreate() const {
    return command_type() == iroha::Command::AssetCreate ? static_cast<const iroha::AssetCreate *>(command()) : nullptr;
  }
  const iroha::AssetAdd *command_as_AssetAdd() const {
    return command_type() == iroha::Command::AssetAdd ? static_cast<const iroha::AssetAdd *>(command()) : nullptr;
  }
  const iroha::AssetRemove *command_as_AssetRemove() const {
    return command_type() == iroha::Command::AssetRemove ? static_cast<const iroha::AssetRemove *>(command()) : nullptr;
  }
  const iroha::AssetTransfer *command_as_AssetTransfer() const {
    return command_type() == iroha::Command::AssetTransfer ? static_cast<const iroha::AssetTransfer *>(command()) : nullptr;
  }
  const iroha::PeerAdd *command_as_PeerAdd() const {
    return command_type() == iroha::Command::PeerAdd ? static_cast<const iroha::PeerAdd *>(command()) : nullptr;
  }
  const iroha::PeerRemove *command_as_PeerRemove() const {
    return command_type() == iroha::Command::PeerRemove ? static_cast<const iroha::PeerRemove *>(command()) : nullptr;
  }
  const iroha::PeerSetActive *command_as_PeerSetActive() const {
    return command_type() == iroha::Command::PeerSetActive ? static_cast<const iroha::PeerSetActive *>(command()) : nullptr;
  }
  const iroha::PeerSetTrust *command_as_PeerSetTrust() const {
    return command_type() == iroha::Command::PeerSetTrust ? static_cast<const iroha::PeerSetTrust *>(command()) : nullptr;
  }
  const iroha::PeerChangeTrust *command_as_PeerChangeTrust() const {
    return command_type() == iroha::Command::PeerChangeTrust ? static_cast<const iroha::PeerChangeTrust *>(command()) : nullptr;
  }
  const iroha::AccountAdd *command_as_AccountAdd() const {
    return command_type() == iroha::Command::AccountAdd ? static_cast<const iroha::AccountAdd *>(command()) : nullptr;
  }
  const iroha::AccountRemove *command_as_AccountRemove() const {
    return command_type() == iroha::Command::AccountRemove ? static_cast<const iroha::AccountRemove *>(command()) : nullptr;
  }
  const iroha::AccountAddSignatory *command_as_AccountAddSignatory() const {
    return command_type() == iroha::Command::AccountAddSignatory ? static_cast<const iroha::AccountAddSignatory *>(command()) : nullptr;
  }
  const iroha::AccountRemoveSignatory *command_as_AccountRemoveSignatory() const {
    return command_type() == iroha::Command::AccountRemoveSignatory ? static_cast<const iroha::AccountRemoveSignatory *>(command()) : nullptr;
  }
  const iroha::AccountSetUseKeys *command_as_AccountSetUseKeys() const {
    return command_type() == iroha::Command::AccountSetUseKeys ? static_cast<const iroha::AccountSetUseKeys *>(command()) : nullptr;
  }
  const iroha::ChaincodeAdd *command_as_ChaincodeAdd() const {
    return command_type() == iroha::Command::ChaincodeAdd ? static_cast<const iroha::ChaincodeAdd *>(command()) : nullptr;
  }
  const iroha::ChaincodeRemove *command_as_ChaincodeRemove() const {
    return command_type() == iroha::Command::ChaincodeRemove ? static_cast<const iroha::ChaincodeRemove *>(command()) : nullptr;
  }
  const iroha::ChaincodeExecute *command_as_ChaincodeExecute() const {
    return command_type() == iroha::Command::ChaincodeExecute ? static_cast<const iroha::ChaincodeExecute *>(command()) : nullptr;
  }
  void *mutable_command() {
    return GetPointer<void *>(VT_COMMAND);
  }
  const flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *signatures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *>(VT_SIGNATURES);
  }
  flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *mutable_signatures() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>> *>(VT_SIGNATURES);
  }
  const flatbuffers::Vector<uint8_t> *hash() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  flatbuffers::Vector<uint8_t> *mutable_hash() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_HASH);
  }
  const Attachment *attachment() const {
    return GetPointer<const Attachment *>(VT_ATTACHMENT);
  }
  Attachment *mutable_attachment() {
    return GetPointer<Attachment *>(VT_ATTACHMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_CREATORPUBKEY) &&
           verifier.Verify(creatorPubKey()) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_COMMAND) &&
           VerifyCommand(verifier, command(), command_type()) &&
           VerifyFieldRequired<flatbuffers::uoffset_t>(verifier, VT_SIGNATURES) &&
           verifier.Verify(signatures()) &&
           verifier.VerifyVectorOfTables(signatures()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HASH) &&
           verifier.Verify(hash()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATTACHMENT) &&
           verifier.VerifyTable(attachment()) &&
           verifier.EndTable();
  }
};

template<> inline const iroha::AssetCreate *Transaction::command_as<iroha::AssetCreate>() const {
  return command_as_AssetCreate();
}

template<> inline const iroha::AssetAdd *Transaction::command_as<iroha::AssetAdd>() const {
  return command_as_AssetAdd();
}

template<> inline const iroha::AssetRemove *Transaction::command_as<iroha::AssetRemove>() const {
  return command_as_AssetRemove();
}

template<> inline const iroha::AssetTransfer *Transaction::command_as<iroha::AssetTransfer>() const {
  return command_as_AssetTransfer();
}

template<> inline const iroha::PeerAdd *Transaction::command_as<iroha::PeerAdd>() const {
  return command_as_PeerAdd();
}

template<> inline const iroha::PeerRemove *Transaction::command_as<iroha::PeerRemove>() const {
  return command_as_PeerRemove();
}

template<> inline const iroha::PeerSetActive *Transaction::command_as<iroha::PeerSetActive>() const {
  return command_as_PeerSetActive();
}

template<> inline const iroha::PeerSetTrust *Transaction::command_as<iroha::PeerSetTrust>() const {
  return command_as_PeerSetTrust();
}

template<> inline const iroha::PeerChangeTrust *Transaction::command_as<iroha::PeerChangeTrust>() const {
  return command_as_PeerChangeTrust();
}

template<> inline const iroha::AccountAdd *Transaction::command_as<iroha::AccountAdd>() const {
  return command_as_AccountAdd();
}

template<> inline const iroha::AccountRemove *Transaction::command_as<iroha::AccountRemove>() const {
  return command_as_AccountRemove();
}

template<> inline const iroha::AccountAddSignatory *Transaction::command_as<iroha::AccountAddSignatory>() const {
  return command_as_AccountAddSignatory();
}

template<> inline const iroha::AccountRemoveSignatory *Transaction::command_as<iroha::AccountRemoveSignatory>() const {
  return command_as_AccountRemoveSignatory();
}

template<> inline const iroha::AccountSetUseKeys *Transaction::command_as<iroha::AccountSetUseKeys>() const {
  return command_as_AccountSetUseKeys();
}

template<> inline const iroha::ChaincodeAdd *Transaction::command_as<iroha::ChaincodeAdd>() const {
  return command_as_ChaincodeAdd();
}

template<> inline const iroha::ChaincodeRemove *Transaction::command_as<iroha::ChaincodeRemove>() const {
  return command_as_ChaincodeRemove();
}

template<> inline const iroha::ChaincodeExecute *Transaction::command_as<iroha::ChaincodeExecute>() const {
  return command_as_ChaincodeExecute();
}

struct TransactionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_creatorPubKey(flatbuffers::Offset<flatbuffers::String> creatorPubKey) {
    fbb_.AddOffset(Transaction::VT_CREATORPUBKEY, creatorPubKey);
  }
  void add_command_type(iroha::Command command_type) {
    fbb_.AddElement<uint8_t>(Transaction::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(Transaction::VT_COMMAND, command);
  }
  void add_signatures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>>> signatures) {
    fbb_.AddOffset(Transaction::VT_SIGNATURES, signatures);
  }
  void add_hash(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash) {
    fbb_.AddOffset(Transaction::VT_HASH, hash);
  }
  void add_attachment(flatbuffers::Offset<Attachment> attachment) {
    fbb_.AddOffset(Transaction::VT_ATTACHMENT, attachment);
  }
  TransactionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransactionBuilder &operator=(const TransactionBuilder &);
  flatbuffers::Offset<Transaction> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Transaction>(end);
    fbb_.Required(o, Transaction::VT_CREATORPUBKEY);
    fbb_.Required(o, Transaction::VT_COMMAND);
    fbb_.Required(o, Transaction::VT_SIGNATURES);
    return o;
  }
};

inline flatbuffers::Offset<Transaction> CreateTransaction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> creatorPubKey = 0,
    iroha::Command command_type = iroha::Command::NONE,
    flatbuffers::Offset<void> command = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<iroha::Signature>>> signatures = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> hash = 0,
    flatbuffers::Offset<Attachment> attachment = 0) {
  TransactionBuilder builder_(_fbb);
  builder_.add_attachment(attachment);
  builder_.add_hash(hash);
  builder_.add_signatures(signatures);
  builder_.add_command(command);
  builder_.add_creatorPubKey(creatorPubKey);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transaction> CreateTransactionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *creatorPubKey = nullptr,
    iroha::Command command_type = iroha::Command::NONE,
    flatbuffers::Offset<void> command = 0,
    const std::vector<flatbuffers::Offset<iroha::Signature>> *signatures = nullptr,
    const std::vector<uint8_t> *hash = nullptr,
    flatbuffers::Offset<Attachment> attachment = 0) {
  return iroha::CreateTransaction(
      _fbb,
      creatorPubKey ? _fbb.CreateString(creatorPubKey) : 0,
      command_type,
      command,
      signatures ? _fbb.CreateVector<flatbuffers::Offset<iroha::Signature>>(*signatures) : 0,
      hash ? _fbb.CreateVector<uint8_t>(*hash) : 0,
      attachment);
}

struct Attachment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *mime() const {
    return GetPointer<const flatbuffers::String *>(VT_MIME);
  }
  flatbuffers::String *mutable_mime() {
    return GetPointer<flatbuffers::String *>(VT_MIME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_MIME) &&
           verifier.Verify(mime()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct AttachmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mime(flatbuffers::Offset<flatbuffers::String> mime) {
    fbb_.AddOffset(Attachment::VT_MIME, mime);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Attachment::VT_DATA, data);
  }
  AttachmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentBuilder &operator=(const AttachmentBuilder &);
  flatbuffers::Offset<Attachment> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Attachment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attachment> CreateAttachment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mime = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  AttachmentBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_mime(mime);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attachment> CreateAttachmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mime = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  return iroha::CreateAttachment(
      _fbb,
      mime ? _fbb.CreateString(mime) : 0,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

}  // namespace iroha

#endif  // FLATBUFFERS_GENERATED_TRANSACTION_IROHA_H_
